<!DOCTYPE html>
<html lang="en">
<head>
    <title>icosahedron</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
    <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css"/>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {"imports": {"three": "https://unpkg.com/three@0.138.0/build/three.module.js","OrbitControls": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js"}}














    </script>
</head>

<body>
</body>

<style>
    body {
        background-color: #ccc;
        color: #000;
    }

    a {
        color: #f00
    }
</style>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script type="module">
    import * as THREE from "three"
    import {OrbitControls} from "OrbitControls"


    class Trinity {
        scene = null
        renderer = null
        camera = null
        controls = null
        socket = io('http://vps2.insource.hu:21000')

        constructor() {

            this.scene = new THREE.Scene()
            this.scene.background = new THREE.Color(0xcccccc)
            this.scene.fog = new THREE.FogExp2(0xcccccc, 0.002)

            this.renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
            })
            this.renderer.shadowMap.enabled = true
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap
            this.renderer.setPixelRatio(window.devicePixelRatio)
            this.renderer.setSize(window.innerWidth, window.innerHeight)
            document.body.appendChild(this.renderer.domElement)

            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
            this.camera.position.set(5, 5, 5)

            this.controls = new OrbitControls(
                this.camera,
                this.renderer.domElement
            )
            this.controls.listenToKeyEvents(window)

            this.controls.enableDamping = true
            this.controls.dampingFactor = 0.05
            this.controls.enablePan = false

            this.controls.minDistance = 1
            this.controls.maxDistance = 10

            window.addEventListener("resize", this.onWindowResize)

            // this.drawIcosahedron()

            this.socket.on("updateTriangle", (triangle) => {
                this.updateTriangle(triangle)
            });

            this.socket.on("reloadTriangle", () => {
                console.log('reloadTriangle')
                this.loadTriangles();
            });

            this.loadTriangles();
        }

        clickListener = () => {
            const raycaster = new THREE.Raycaster()
            // A kattintás eseményfigyelője
            document.addEventListener("mousedown", (event) => {
                const mouse = new THREE.Vector2()
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

                raycaster.setFromCamera(mouse, this.camera)

                const intersects = raycaster.intersectObjects(
                    this.scene.children,
                    true
                )

                if (intersects.length > 0) {
                    let selectedItem = null
                    for (let i = 0; i < intersects.length; i++) {
                        const row = intersects[i].object
                        if (row.geometry.attributes.clickCount.array[0] > 10) continue

                        selectedItem = row
                    }

                    if (selectedItem == null) {
                        console.log('is null')
                        return
                    }

                    console.log(selectedItem)

                    if (selectedItem.geometry.attributes.clickCount.array[0] >= 10) {
                        if (this.needSubdivide()) {
                            this.subdivideIco()
                        }
                    } else {
                        this.nextFace(selectedItem)
                    }
                }
            })

            return this
        }

        needSubdivide = () => {
            return false
        }

        drawIcosahedron = (result) => {
            this.clear()
            result.forEach(row => {
                const vert = new Float32Array([
                    row.pos1.x, row.pos1.y, row.pos1.z,
                    row.pos2.x, row.pos2.y, row.pos2.z,
                    row.pos3.x, row.pos3.y, row.pos3.z,
                ])

                this.drawTriangle(
                    row.uuid,
                    this.scene,
                    new THREE.MeshBasicMaterial({color: 0xffffff}),
                    vert,
                    row.click
                )
            })

            return this
        }

        clear = () => {
            for (let i = this.scene.children.length - 1; i >= 0; i--) {
                const obj = this.scene.children[i];
                this.scene.remove(obj);
            }
        }

        onWindowResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()

            renderer.setSize(window.innerWidth, window.innerHeight)
        }

        animate = () => {
            requestAnimationFrame(this.animate)
            this.controls.update()
            this.render()

            return this
        }

        render = () => {
            this.renderer.render(this.scene, this.camera)
        }

        updateTriangle(triangle) {
            const object = this.scene.getObjectByProperty('uuid', triangle.uuid);
            const percent = 100 - triangle.click * 10

            object.geometry.attributes.clickCount.array[0] = triangle.click
            object.material.color.setRGB(percent / 100, percent / 100, percent / 100)
        }

        nextFace = (object) => {
            this.socket.emit('clickTriangle', object.uuid);
            const clickCount = object.geometry.attributes.clickCount.array[0]++
            const percent = 100 - clickCount * 10

            object.material.color.setRGB(percent / 100, percent / 100, percent / 100)
        }

        drawTriangle = (uuid, parent, material, vertices, click = 1, needBorder = true) => {
            if (needBorder) {
                this.drawTriangle(null, parent, new THREE.MeshStandardMaterial({
                    wireframe: true,
                    color: 0xff0000
                }), vertices, 10, false)

                const percent = 100 - click * 10
                material.color.setRGB(percent / 100, percent / 100, percent / 100)
            }
            const clickCount = new Float32Array([click])
            const geometry = new THREE.BufferGeometry()

            geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2]), 1))
            geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3))
            geometry.setAttribute("clickCount", new THREE.BufferAttribute(clickCount, 3))

            const triangle = new THREE.Mesh(geometry, material)
            if (uuid !== null) triangle.uuid = uuid

            parent.add(triangle)
        }

        loadTriangles() {

            fetch("http://vps2.insource.hu:21080/triangles", {
                method: 'GET',
                redirect: 'follow'
            })
                .then(response => response.text())
                .then(result => this.drawIcosahedron(JSON.parse(result)))
                .catch(error => console.log('error', error))
        }
    }

    new Trinity().clickListener().animate()
</script>
</html>
