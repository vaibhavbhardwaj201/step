<!DOCTYPE html>
<html lang="en">
<head>
    <title>Finding Narimato</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
    <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css"/>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;300;500;700&display=swap" rel="stylesheet">
    <link href="assets/style.css" rel="stylesheet">

    <script type="importmap">
        {"imports": {"three": "https://unpkg.com/three@0.138.0/build/three.module.js","OrbitControls": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js"}}


    </script>

    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-N6KJR3MQV8"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'G-N6KJR3MQV8');
    </script>
</head>

<body class="overflow-hidden">
<div class="fixed left-5 top-5 text-left gap-5 p-3">
    <div class="text-xl mb-5" id="levelName"></div>
    <div class="grid grid-cols-[200px_50px] gap-2">
        <p>Level:</p>
        <span id="level">0</span>

        <p>Your click:</p>
        <span id="yourClick">0</span>

        <p>Clicks of this world:</p>
        <span id="currentClick">0</span>

        <p>All the clicks in the universe:</p>
        <span id="allClick">0</span>

        <p>Number of terraformed worlds:</p>
        <span id="reload">0</span>
    </div>
</div>

<a href="https://insource.hu" target="_blank">
    <div class="fixed bottom-0 -right-[88px] w-[120px] h-[32px] transition-all duration-300 flex items-center cursor-pointer bg-white hover:right-0">
        <img src="/is.webp" alt="fejlesztő logója" class="max-w-[32px] p-[8px]">
        <p class="text-xs text-black">Developed by</p>
    </div>
</a>
</body>

<style>
    body {
        background-color: #ccc;
        font-family: 'Inter', sans-serif;
        color: #000;
    }

    a {
        color: #f00
    }
</style>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script type="module">
    import * as THREE from "three"
    import {OrbitControls} from "OrbitControls"


    class Narimato {
        scene = null
        renderer = null
        camera = null
        controls = null
        yourClick = 0
        level = 0
        colors = [
            [0xFFFFFF, 0xDAE4F5, 0xB4C9EB, 0x8FADE0, 0x6992D6, 0x4477CC],
            [0x4477CC, 0x4B88AD, 0x52998F, 0x58AA70, 0x5FBB52, 0x66CC33],
            [0x66CC33, 0x85CF36, 0xA3D33A, 0xC2D63D, 0xE0DA41, 0xFFDD44],
            [0xFFDD44, 0xD6B83D, 0xAD9236, 0x856D30, 0x5C4729, 0x332222],
            [0x332222, 0x5C1B2C, 0x851436, 0xAD0E41, 0xD6074B, 0xFF0055],
            [0xFF0055, 0xFF3377, 0xFF6699, 0xFF99BB, 0xFFCCDD, 0xFFFFFF],
        ]
        host = 'https://narimato.com:21000'
        socket = io(this.host, {secure: true})
        levelName = ['Realm of Ice', 'The Source', 'Under the Rocks', 'Chase the Sun', 'Unknown Step']

        constructor() {

            this.yourClick = getCookie('click') ?? 0

            this.scene = new THREE.Scene()
            this.scene.background = new THREE.Color(0xcccccc)
            this.scene.fog = new THREE.FogExp2(0xcccccc, 0.002)

            this.renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
            })
            this.renderer.shadowMap.enabled = true
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap
            this.renderer.setPixelRatio(window.devicePixelRatio)
            this.renderer.setSize(window.innerWidth, window.innerHeight)
            document.body.appendChild(this.renderer.domElement)

            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
            this.camera.position.set(5, 5, 5)

            this.controls = new OrbitControls(
                this.camera,
                this.renderer.domElement
            )
            this.controls.listenToKeyEvents(window)

            this.controls.enableDamping = true
            this.controls.dampingFactor = 0.05
            this.controls.enablePan = false

            this.controls.minDistance = 1
            this.controls.maxDistance = 10

            window.addEventListener("resize", this.onWindowResize)

            this.socket.on("update", (data) => {
                this.updateTriangle(data.triangle)
                this.updateText(data.allClick, data.currentClick, data.level, data.reload)
                this.level = data.level - 1
            })

            this.socket.on("reloadTriangle", (data) => {
                if (data !== undefined) {
                    this.updateText(data.allClick, data.currentClick, data.level, data.reload)
                    this.level = data.level - 1
                }

                this.loadTriangles()
            })

            // this.loadTriangles()
        }

        clickListener = () => {
            const raycaster = new THREE.Raycaster()

            document.addEventListener("mousedown", (event) => {
                const mouse = new THREE.Vector2()
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

                raycaster.setFromCamera(mouse, this.camera)

                const intersects = raycaster.intersectObjects(
                    this.scene.children,
                    true
                )

                if (intersects.length > 0) {
                    let selectedItem = null
                    for (let i = 0; i < intersects.length; i++) {
                        const row = intersects[i].object
                        if (row.geometry.attributes.clickCount.array[0] > 5) continue

                        selectedItem = row
                    }

                    if (selectedItem == null) {
                        return
                    }

                    if (selectedItem.geometry.attributes.clickCount.array[0] < 5) {
                        this.nextFace(selectedItem)
                    }
                }
            })

            return this
        }

        drawIcosahedron = (result) => {
            this.clear()
            result.forEach(row => {
                const vert = new Float32Array([
                    row.pos1.x, row.pos1.y, row.pos1.z,
                    row.pos2.x, row.pos2.y, row.pos2.z,
                    row.pos3.x, row.pos3.y, row.pos3.z,
                ])

                this.drawTriangle(
                    row.uuid,
                    this.scene,
                    new THREE.MeshBasicMaterial({color: 0xffffff}),
                    vert,
                    row.click
                )
            })

            return this
        }

        clear = () => {
            for (let i = this.scene.children.length - 1; i >= 0; i--) {
                const obj = this.scene.children[i]
                this.scene.remove(obj)
            }
        }

        onWindowResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()

            renderer.setSize(window.innerWidth, window.innerHeight)
        }

        animate = () => {
            requestAnimationFrame(this.animate)
            this.controls.update()
            this.render()

            return this
        }

        render = () => {
            this.renderer.render(this.scene, this.camera)
        }

        updateTriangle(triangle) {
            const object = this.scene.getObjectByProperty('uuid', triangle.uuid)

            object.geometry.attributes.clickCount.array[0] = triangle.click
            this.setColor(object.material.color, triangle.click)
        }

        updateText(allClick, currentClick, level, reload) {
            document.getElementById('allClick').innerHTML = allClick
            document.getElementById('currentClick').innerHTML = currentClick
            document.getElementById('level').innerHTML = level
            document.getElementById('reload').innerHTML = reload
            document.getElementById('levelName').innerHTML = this.levelName[level]

            document.getElementById('yourClick').innerHTML = this.yourClick.toString()
        }

        nextFace = (object) => {
            this.yourClick++
            setCookie('click', this.yourClick)

            this.socket.emit('clickTriangle', object.uuid)
            const clickCount = object.geometry.attributes.clickCount.array[0]++

            this.setColor(object.material.color, clickCount)
        }

        drawTriangle = (uuid, parent, material, vertices, click = 1, needBorder = true) => {
            if (needBorder) {
                this.drawTriangle(null, parent, new THREE.MeshStandardMaterial({
                    wireframe: true,
                    color: 0xff0000
                }), vertices, 10, false)


                this.setColor(material.color, click)
            }
            const clickCount = new Float32Array([click])
            const geometry = new THREE.BufferGeometry()

            geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2]), 1))
            geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3))
            geometry.setAttribute("clickCount", new THREE.BufferAttribute(clickCount, 3))

            const triangle = new THREE.Mesh(geometry, material)
            if (uuid !== null) triangle.uuid = uuid

            parent.add(triangle)
        }

        setColor(color, click) {
            color.setHex(this.colors[this.level][click])
        }

        loadTriangles() {

            fetch(this.host + "/triangles", {
                method: 'GET',
                redirect: 'follow'
            })
                .then(response => response.text())
                .then(result => this.drawIcosahedron(JSON.parse(result)))
                .catch(error => console.log('error', error))
        }
    }

    function setCookie(cname, cvalue) {
        const d = new Date();
        d.setTime(d.getTime() + 31536000000);
        let expires = "expires=" + d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }

    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return null;
    }

    new Narimato().clickListener().animate()
</script>
</html>
